var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import styled from 'styled-components';
import { useClickOutside, useGlobalKeyDown } from '../../hooks';
import { Box, Stack } from '../../primitives';
import { useLayer } from '../../utils';
import { getFocusableElements } from './helpers';
import { MenuContext } from './menuContext';
const Root = styled(Box) `
  outline: none;
`;
export const Menu = forwardRef((props, ref) => {
    const { children, focusLast, onClickOutside, onEscape, onItemClick, padding = 1, space = 1 } = props, restProps = __rest(props, ["children", "focusLast", "onClickOutside", "onEscape", "onItemClick", "padding", "space"]);
    const { isTopLayer } = useLayer();
    const [rootElement, setRootElement] = useState(null);
    const itemsRef = useRef([]);
    const [activeIndex, setActiveIndex] = useState(-1);
    useEffect(() => {
        const rafId = window.requestAnimationFrame(() => {
            if (rootElement) {
                const element = itemsRef.current[focusLast ? itemsRef.current.length - 1 : 0];
                if (element) {
                    element.focus();
                    setActiveIndex(itemsRef.current.indexOf(element));
                }
            }
        });
        return () => {
            window.cancelAnimationFrame(rafId);
        };
    }, [focusLast, rootElement]);
    const setRef = (el) => {
        setRootElement(el);
        if (typeof ref === 'function')
            ref(el);
        else if (ref)
            ref.current = el;
    };
    const mount = useCallback((element) => {
        if (!element)
            return () => undefined;
        if (!itemsRef.current.includes(element)) {
            itemsRef.current.push(element);
        }
        return () => {
            const idx = itemsRef.current.push(element);
            if (idx > -1) {
                itemsRef.current.splice(idx, 1);
            }
        };
    }, []);
    const handleKeyDown = useCallback((event) => {
        if (event.key === 'ArrowUp') {
            event.preventDefault();
            const focusableElements = getFocusableElements(itemsRef.current);
            const focusableLen = focusableElements.filter(({ focusable }) => focusable).length;
            if (focusableLen === 0)
                return;
            const len = focusableElements.length;
            let currentIndex = activeIndex;
            let focusable = false;
            let element = null;
            while (!focusable) {
                currentIndex = (currentIndex - 1 + len) % len;
                element = focusableElements[currentIndex].element;
                focusable = focusableElements[currentIndex].focusable;
            }
            setActiveIndex(currentIndex);
            if (element)
                element.focus();
            return;
        }
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            const focusableElements = getFocusableElements(itemsRef.current);
            const focusableLen = focusableElements.filter(({ focusable }) => focusable).length;
            if (focusableLen === 0)
                return;
            const len = focusableElements.length;
            let currentIndex = activeIndex;
            let focusable = false;
            let element = null;
            while (!focusable) {
                currentIndex = (currentIndex + 1) % len;
                element = focusableElements[currentIndex].element;
                focusable = focusableElements[currentIndex].focusable;
            }
            setActiveIndex(currentIndex);
            if (element)
                element.focus();
            return;
        }
    }, [activeIndex]);
    const handleItemMouseEnter = useCallback((event) => {
        const element = event.currentTarget;
        setActiveIndex(itemsRef.current.indexOf(element));
        element.focus();
    }, []);
    const handleItemMouseLeave = useCallback(() => {
        setActiveIndex(-1);
        rootElement === null || rootElement === void 0 ? void 0 : rootElement.focus();
    }, [rootElement]);
    useClickOutside(useCallback(() => isTopLayer && onClickOutside && onClickOutside(), [
        isTopLayer,
        onClickOutside,
    ]), [rootElement]);
    useGlobalKeyDown(useCallback((event) => {
        if (!isTopLayer)
            return;
        if (event.key === 'Escape') {
            event.stopPropagation();
            if (onEscape)
                onEscape();
        }
    }, [isTopLayer, onEscape]));
    const value = useMemo(() => ({
        version: 0.0,
        activeIndex,
        mount,
        onMouseEnter: handleItemMouseEnter,
        onMouseLeave: handleItemMouseLeave,
        onItemClick,
    }), [activeIndex, mount, handleItemMouseEnter, handleItemMouseLeave, onItemClick]);
    return (React.createElement(MenuContext.Provider, { value: value },
        React.createElement(Root, Object.assign({ "data-ui": "Menu" }, restProps, { onKeyDown: handleKeyDown, padding: padding, ref: setRef, role: "menu", tabIndex: -1 }),
            React.createElement(Stack, { space: space }, children))));
});
Menu.displayName = 'Menu';
//# sourceMappingURL=menu.js.map